---
layout: post
title: The MSP430 Central Processing Unit
date: '2010-10-26T07:27:00.002+05:30'
author: Hari John Kuriakose
tags:
- embedding
- MSP430G2231
- computing
modified_time: '2010-11-03T11:22:28.767+05:30'
thumbnail: http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYn_0w0cKI/AAAAAAAAAUU/Uj9b6z4mYA0/s72-c/IMG_7330.JPG
blogger_id: tag:blogger.com,1999:blog-3368921059404601044.post-7133309550293653052
blogger_orig_url: http://harijohnkuriakose.blogspot.com/2010/10/msp430-central-processing-unit.html
---

MSP430 has 4 special purpose and 12 general purpose registers.<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYn_0w0cKI/AAAAAAAAAUU/Uj9b6z4mYA0/s1600/IMG_7330.JPG" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYn_0w0cKI/AAAAAAAAAUU/Uj9b6z4mYA0/s320/IMG_7330.JPG" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 1. The MSP430 LaunchPad from TI</td></tr></tbody></table><br />The registers in MSP430 are:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYlIda6pEI/AAAAAAAAAUI/YgZ6C53TSMM/s1600/1.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="158" src="http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYlIda6pEI/AAAAAAAAAUI/YgZ6C53TSMM/s320/1.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 2. The registers in MSP430</td></tr></tbody></table><br /><b>Program Counter</b> <b>(PC)</b><br /><br />The program counter stores the address of the instruction which is to be executed next.<br /><br />For the execution of each instruction, first the address stored in the PC is placed in the address bus. Then, the instruction stored in this address is fetched. Meanwhile, the PC is automatically incremented by 2, i.e, PC now contains the address of the next instruction. The current instruction is now executed, and the next instruction fetched simultaneously.<br /><br />This is the normal procedure, unless a jump instruction is encountered. In such cases, the PC is incremented by an offset contained in the opcode of the jump instruction. For interrupts and subroutines, the return address needs to be stored in the stack pointer before jumping.<br /><br />An instruction comprises of 1-3 words, which are aligned to even addresses. So the LSB is hardwired to zero.<br /><br /><b>Stack Pointer (SP)</b><br /><br />In MSP 430, the top of the RAM (12b bytes) is initially allotted to the stack pointer. Further writings into the stack are performed at lower addresses (<b>goes downwards</b>).<br />Also, the lsb of a stack address is always hardwired to zero, i.e., <b>stack addresses always point to words</b>. If only a byte is written into the stack, then one byte will be wasted to preserve this alignment.<br /><br />In assembly language, after a reset, the stack pointer must be explicitly initialized to 0x280.<br /><b><br /></b><br /><b>Predecrement addressing</b> (Pushing) - To insert a new value into the stack, first the stack pointer is decremented by 2, then writing is performed.<br /><b>Postincrement addressing</b> (Popping) - To delete the current value in the stack pointer, first the value is deleted, then the stack pointer is incremented by 2.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYmL6nLGvI/AAAAAAAAAUM/G37Neu_C5Bo/s1600/2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://3.bp.blogspot.com/_rkBB8V8TgZY/TMYmL6nLGvI/AAAAAAAAAUM/G37Neu_C5Bo/s320/2.png" width="293" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 3. Basic stack operations in MSP430</td></tr></tbody></table><br /><b>Status Register (SR)</b><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/_rkBB8V8TgZY/TMYmmetuicI/AAAAAAAAAUQ/FzyQHDD6q60/s1600/3.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="41" src="http://1.bp.blogspot.com/_rkBB8V8TgZY/TMYmmetuicI/AAAAAAAAAUQ/FzyQHDD6q60/s320/3.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 4. The Status Register</td></tr></tbody></table><b>N</b> - Negative Flag<br /><b>Z</b> - Zero Flag<br /><b>C</b> - Carry flag<br /><b>V</b> - Signed Overflow Flag<br /><b>GIE</b> - General Interupt Enable<br /><b>SCG1</b>, <b>SCG0</b>, <b>OSC OFF</b>, <b>CPU OFF</b> - Control of Low Power Modes<br /><b><span class="Apple-style-span" style="font-weight: normal;"><br /></span></b><br /><b><span class="Apple-style-span" style="font-weight: normal;">The SR also acts as constant generator CG0.</span></b><br /><b><br /></b><br /><b>Constant Generator (CG0, CG1)</b><br />Both R2 and R3 are used to generate 6 most frequently used constants. This saves fetching time. The constant generated depends on the addressing mode used.<br /><br /><b>General Purpose Registers</b><br />There are 12 of them, <b>R4 - R15</b>. They can be used to store address or data, since both are 16 bit in the MSP430 family. This leads to considerable simplification in the operations.