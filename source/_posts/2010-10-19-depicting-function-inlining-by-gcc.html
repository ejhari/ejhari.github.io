---
layout: post
title: Depicting Function Inlining by GCC
date: '2010-10-19T17:40:00.001+05:30'
author: Hari John Kuriakose
tags:
- C
- computing
modified_time: '2010-11-25T22:04:56.283+05:30'
blogger_id: tag:blogger.com,1999:blog-3368921059404601044.post-8440283918011188248
blogger_orig_url: http://harijohnkuriakose.blogspot.com/2010/10/depicting-function-inlining-by-gcc.html
---

<b><u>Inline Function</u></b><br /><br />In C, if a particular function used has only a few lines in its body, and if the optimization level is set to 03 (preferably), some unexpected changes can be observed about how gcc handles this function.<br /><br />What the compiler will do is that it replaces the call for this function, with the actual code of the function, called <b>inlining</b>.<br /><br /><b>The limit on the number of lines below which inlining is performed, strictly depends upon the gcc heuristics.</b><br /><br />This is not all. In &nbsp;the extreme case, if the small function mentioned above only does something like calculating a value after taking an input, then gcc will evaluate the function call, calculate the value, and directly paste it in the program instead of the function call itself.<br /><br />Sweet, isn't it? &nbsp; <br /><br /><b><u>Test Program</u></b><br /><b><u><br /></u></b><br /><br />&nbsp;&nbsp; &nbsp;int sqr(int x)<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int a;<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return x*x;<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br /><br />&nbsp;&nbsp; &nbsp;main()<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n", sqr(10));<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br /><div><br /></div><div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><b><u>Assembly Code</u></b></div></div><div><br /></div><div>To view the assembly code.</div><div>&nbsp;&nbsp; &nbsp;<b>gcc -S -fomit-frame-pointer opt1.c</b></div><br />&nbsp;&nbsp; &nbsp;<b>less opt1.s</b><br /><b><br /></b><br />The assembly code is:<br />&nbsp;&nbsp; &nbsp;sqr:<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;subl &nbsp; &nbsp;$16, %esp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;20(%esp), %eax<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;imull &nbsp; 20(%esp), %eax<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addl &nbsp; &nbsp;$16, %esp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp;&nbsp; &nbsp;main:<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pushl &nbsp; %ebp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;%esp, %ebp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;andl &nbsp; &nbsp;$-16, %esp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>subl &nbsp; &nbsp;$16, %esp</b><br /><b>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;$10, (%esp)</b><br /><b>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;sqr</b><br /><b>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;%eax, 4(%esp)</b><br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;$.LC0, (%esp)<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;printf<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;leave<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />On optimization,<br /><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"></div><div><b>&nbsp;&nbsp; &nbsp;gcc -S -O3 -fomit-frame-pointer opt1.c</b></div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<b>less opt1.s</b></div><br />The new code is:<br /><br />&nbsp;&nbsp; &nbsp;sqr:<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;4(%esp), %eax<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;imull &nbsp; %eax, %eax<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp;&nbsp; &nbsp;main:<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pushl &nbsp; %ebp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;%esp, %ebp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;andl &nbsp; &nbsp;$-16, %esp<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>subl &nbsp; &nbsp;$16, %esp</b><br /><b>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;$100, 4(%esp)</b><br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movl &nbsp; &nbsp;$.LC0, (%esp)<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call &nbsp; &nbsp;printf<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;leave<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br /><br /><div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Here, the function&nbsp;<b>sqr( )</b>&nbsp;does something very simple, and the input to the function is statically assigned. It means that the value of the input (<b>10</b>) will never change during runtime. Hence, the compiler will optimize the program even further, to the extreme that the square of 10 will be evaluated and the result pasted in the program instead of the original call to the function sqr( ). &nbsp;</div></div>