---
layout: post
title: The Addressing Modes in the MSP430 Family
date: '2010-10-26T07:29:00.000+05:30'
author: Hari John Kuriakose
tags:
- embedding
- MSP430G2231
- computing
modified_time: '2010-10-26T07:29:14.736+05:30'
thumbnail: http://4.bp.blogspot.com/_rkBB8V8TgZY/TMYq_-qXLsI/AAAAAAAAAUY/7NpULFeHm08/s72-c/IMG_7338.JPG
blogger_id: tag:blogger.com,1999:blog-3368921059404601044.post-1162113949818946879
blogger_orig_url: http://harijohnkuriakose.blogspot.com/2010/10/addressing-modes-in-msp430-family.html
---

<b><u></u></b><br /><b><u><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_rkBB8V8TgZY/TMYq_-qXLsI/AAAAAAAAAUY/7NpULFeHm08/s1600/IMG_7338.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="240" src="http://4.bp.blogspot.com/_rkBB8V8TgZY/TMYq_-qXLsI/AAAAAAAAAUY/7NpULFeHm08/s320/IMG_7338.JPG" width="320" /></a></div><div><b><u><br /></u></b></div><div><b><u><br /></u></b></div><div><span class="Apple-style-span" style="-webkit-text-decorations-in-effect: none; font-weight: normal;"><b><u>Register Mode</u></b></span></div></u></b><br /><br /><b>mov.w</b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>R4,R5</b><span class="Apple-tab-span" style="white-space: pre;"> </span>; move (copy) word from R4 to R6<br /><br />It is the fastest, with&nbsp;only 1 machine cycle needed.<br />Any of the 16 registers can be used as source or destination.<br /><br />Special cases:<br /><ul><li><span class="Apple-tab-span" style="white-space: pre;"> </span>PC - it will be autoincremented before it is used as source</li><li><span class="Apple-tab-span" style="white-space: pre;"> </span>Both PC and SP must be even, because they are always used as words. so &nbsp;LSB discarded if they are used as destination</li><li><span class="Apple-tab-span" style="white-space: pre;"> </span>CG2 - it reads 0 as source</li></ul>for byte operations:<br /><ul><li><span class="Apple-tab-span" style="white-space: pre;"> </span>operand is taken from lower byte only</li><li><span class="Apple-tab-span" style="white-space: pre;"> </span>writing is performed to lower byte only, upper byte is cleared</li></ul>To use the upper byte in a regiser as source, '<b>swpb</b>' may be used.<br /><br /><b><u>Indexed Mode</u></b><u>&nbsp;</u><br /><br />Similar to arrays.<br /><br /><b>mov.b </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>3(R5),R6</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>; load byte from address 3+(R5) into R6<br /><br />Here, base address is 3.<br />Indexing can be used for the source or destination part.<br /><br /><b><u>Symbolic Mode</u></b><u> </u><b><u>(PC Relative)</u></b><br /><br />When PC is used as the base address in the indexed mode, its called symbolic mode by TI. The offset to be added to the PC is given as the constant.<br /><br />mov.w <span class="Apple-tab-span" style="white-space: pre;"> </span>Loop,R6 <span class="Apple-tab-span" style="white-space: pre;"> </span>; load word Loop into R6<br /><br />Assembler replaces this as:<br /><br /><b>mov.w </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b> X(PC),R6 </b><span class="Apple-tab-span" style="white-space: pre;"> </span>;<br /><br />where X = Loop - PC, is the offset in this case. It is caluclated by the assembler, which also performs autoincrementing of PC.<br /><br />In MSP430, absolute addressing can reach all the memory map. The symbolic mode is mainly meant for MSP430X, etc.<br /><br /><b><u>Absolute Mode</u></b><br /><br />This is a special case where the constant in the indexed mode is the absolute address of the data. Since the constant is already the final address, the base must be taken as an address of 0. Usually the SR is selected for this purpose. It behaves as 0 when used as the base, i.e, this is one instance when the SR behaves as a constant generator (CG1).<br /><br />Absolute addressing is shown by the prefix &amp;.<br /><br /><b>mov.b </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>P1IN,R6</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>; load byte P1IN into R6<br /><br />It is replaced by the assembler as:<br /><br /><b>mov.b </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>P1IN(SR),R6</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>;<br /><br />P1IN is the offset, and SR behaves as 0.<br /><br /><b><u>SP-Relative</u></b><br /><br />This is not a separate mode in itself. At any time, any value pushed into the stack previously can be accessed, by offseting a suitable amount from the SP. For example:<br /><br /><b>mov.w </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>2(SP),R6</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>;<br /><br /><b><u>Indirect Register Mode</u></b><br /><br />This is available only for the source. It is indicated by the sign <b>@</b>. It means that the contents of a register is used as the address of the operand, i.e, the register contains a "pointer" to the actual operand.<br /><br /><b>mov.w </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>@R5,R6</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>; load word from address pointed to by R5<br /><br />This is similar to indexed addressing with base address 0. It saves a word of program memory, hence makes it faster.<br /><br />This mode cannot be used for destination. Using indexed addressing instead:<br /><br /><b>mov.w </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>R6,0(R5)</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>; store word from R6 into address 0+(R5)<br /><br />There is a penalty that a word 0 must be stored in the program memory, and fetched. The constant generator cannot be used.<br /><br /><b><u>Indirect Autoincrement Register Mode</u></b><br /><br />This is also available only for the source. It is indicated by a <b>@ in the front, and a + as suffix</b>. Here, the register is used as a pointer as in the indirect register mode. After this, the value in the register is autoincremented by 1 if a byte has been fetched, or by 2 if a word has been fetched.<br /><br /><b>mov.w @R5+, R6</b><br /><br />Since this mode cannot be used for destination, the indexed addressing mode must be used and then explicitly incrementing the value of the register appropriately. Obviously, two instructions would be required.<br /><br /><b>N.B.</b><br /><ul><li>MSP430 only has postincrement addressing.</li><li>In all the addressing modes, all operations on the first address are fully&nbsp;completed before the second address is evaluated.</li></ul><br /><b><u>Immediate Mode</u></b><br /><br />It is a special case of autoincrement addressing that uses program counter PC. For example:<br /><br /><b>mov.w </b><span class="Apple-tab-span" style="white-space: pre;"><b> </b></span><b>@PC+,R6</b> <span class="Apple-tab-span" style="white-space: pre;"> </span>;<br /><br />Here, after the instruction pointed to by PC has been fetched, PC is autoincremented, i.e., PC now points to the next instruction. This particular instruction will be the one copied into R6.