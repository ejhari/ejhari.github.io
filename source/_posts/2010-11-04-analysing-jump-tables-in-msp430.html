---
layout: post
title: Analysing Jump Tables in MSP430 Assembly Code
date: '2010-11-04T16:31:00.002+05:30'
author: Hari John Kuriakose
tags:
- embedding
- MSP430G2231
- computing
modified_time: '2010-11-25T21:50:24.956+05:30'
thumbnail: http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJCONGzuNI/AAAAAAAAAVA/uqo82UEsxJM/s72-c/1.png
blogger_id: tag:blogger.com,1999:blog-3368921059404601044.post-2427331664746843163
blogger_orig_url: http://harijohnkuriakose.blogspot.com/2010/11/analysing-jump-tables-in-msp430.html
---

<div><b><u>Jump Table</u></b></div><div><br /></div><div>A jump table is an array of pointers to functions or an array of assembly code jump instructions.&nbsp;</div><div><br /></div><div>In assembling, jump tables are the most efficient method to handle switch statements with a large number of cases. The jump table is created only once and the required field in the table can be accessed simply by indexing.</div><div><br /></div><div>Especially in embedded systems, where there is a heavy constraint in available memory, jump tables can be efficient while consuming lesser memory too.</div><div><br /></div><div><b><u>Sample Program</u></b></div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJCONGzuNI/AAAAAAAAAVA/uqo82UEsxJM/s1600/1.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="285" src="http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJCONGzuNI/AAAAAAAAAVA/uqo82UEsxJM/s320/1.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 1. Sample Program</td></tr></tbody></table><div>The switch has only four cases, hence there is no need for a jump table. The cases are implemented simply as:</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_rkBB8V8TgZY/TNJKAj7Wa3I/AAAAAAAAAVE/FuavTnI3YJ4/s1600/2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://2.bp.blogspot.com/_rkBB8V8TgZY/TNJKAj7Wa3I/AAAAAAAAAVE/FuavTnI3YJ4/s320/2.png" width="254" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 2. The switch implementation without jump table</td></tr></tbody></table><div>The behavior is almost as expected.</div><div>Now, I need a switch with enough cases, to get the attention of the gcc compiler heuristics.</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJLnwtwmEI/AAAAAAAAAVI/l8PmcyJu8nE/s1600/3.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJLnwtwmEI/AAAAAAAAAVI/l8PmcyJu8nE/s320/3.png" width="273" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 3. More cases for the switch</td></tr></tbody></table><div>I have to check the corresponding assembly code generated for the above program, to be sure.</div><div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/_rkBB8V8TgZY/TNJwzBLGzVI/AAAAAAAAAVY/ZBpv1WCRqww/s1600/4.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="250" src="http://1.bp.blogspot.com/_rkBB8V8TgZY/TNJwzBLGzVI/AAAAAAAAAVY/ZBpv1WCRqww/s320/4.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 4. Lookup table created - PartI</td></tr></tbody></table></div><div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJwxOCFTRI/AAAAAAAAAVU/mhRDcq4gx7I/s1600/5.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://4.bp.blogspot.com/_rkBB8V8TgZY/TNJwxOCFTRI/AAAAAAAAAVU/mhRDcq4gx7I/s320/5.png" width="311" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 5. Lookup table created - PartII</td></tr></tbody></table></div><div>&nbsp;It worked, the compiler decided that a jump table is really essential now.<br /><br />The "mov #1,@r4" line stores the value of variable "i". There are 8 cases, numbered from 0 to 7. Hence first "i", i.e, @r4 is compared with 8, for obvious reasons.<br /><br /><b><u>Analysing the 'jump table'</u></b><br /><br />The <b>jump table has been created, starting from the address denoted by the label ".L11"</b>.<br /><br />The first entry in the table holds label ".L3" which is the starting address &nbsp;of the block of&nbsp;statements under "case 0:".<br />The next entry is ".L4", which is the starting address of the block of statements under "case 1:".<br />And so on ... Till "case 7:".<br />There are <b>8 ".word"s in the jump table</b> too. Correct!<br /><br />The line N in the jump table holds the starting address of the block of statements under the corresponding "case N:". In other words, each line is the offset to be added to ".L11", to execute the required case statements.<br /><br /><b><u>Decoding ...</u></b><br /><br />"r15" holds the value to be switched.<br /><br />"<b>rla r15</b>" rotates left arithmetically the value inside r15, once (multiplication by 2).<br />Remember that even addressing is required for MSP430 family. <br /><br />"<b>add #.L11,r15</b>" adds the present value of "r15" (similar to offset), with the address of the &nbsp;label ".L11" (similar to base address).<br />"r15" now contains the address of the line that lies at the given offset from ".L11".<br /><br />After the "<b>mov @r15,r15</b>" line, "r15" now contains the starting address of a block of statements under the selected "case".<br /><br />"<b>br r15</b>" simply branches to the address pointed to by r15.<br /><br />Clean.<br /><br /><b><u>Issues</u></b><br /><ul><li>How can you justify that <b>jump tables are friendly to embedded systems</b>?</li></ul>Its true that a jump table has a particular overhead for itself.<br /><br />Suppose there are a very large number of switch cases. Then, this "jump to index" overhead will be much lower than the cost to perform N case comparisons. That is why jump tables are usually preferred.<br /><ul><li><b>Jump tables work only when the case identifiers are consecutive</b>.</li></ul>For example, case 1, case 2, case 3, etc ...<br /><br />In situations where the cases are random and spread over a large range, suitable searching methods are needed. Normally, binary search is used. The correct case can then be selected in 3 or 4 steps without performing N comparisons each time.</div>