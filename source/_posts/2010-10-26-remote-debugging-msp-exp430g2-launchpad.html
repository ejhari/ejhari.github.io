---
layout: post
title: Remote Debugging the MSP-EXP430G2 LaunchPad from TI
date: '2010-10-26T17:55:00.002+05:30'
author: Hari John Kuriakose
tags:
- embedding
- MSP430G2231
- computing
modified_time: '2010-11-03T11:00:57.601+05:30'
thumbnail: http://1.bp.blogspot.com/_rkBB8V8TgZY/TMbCTvv1f9I/AAAAAAAAAUs/kPrwRO6vT2M/s72-c/led1.png
blogger_id: tag:blogger.com,1999:blog-3368921059404601044.post-3820744296317253648
blogger_orig_url: http://harijohnkuriakose.blogspot.com/2010/10/remote-debugging-msp-exp430g2-launchpad.html
---

<b><u>Remote Debugging in GDB</u></b><br /><br /><div>There is an inbuilt ability for gdb to also debug programs that reside in remote machines using a gdb-specific protocol. The remote machine is connected to the host via a serial line, or through a port. This remote connection is called a gdb <b>proxy</b>.<br /><br />While inside gdb, give as:<br />&nbsp;&nbsp; &nbsp;<b>(gdb) target remote localhost:2000</b><br /><br />This would enable gdb to perform all debugging operations on a program connected to the localhost machine through the port 2000.<br /><br />There is a prerequisite that the machine that is to be present in the same port must have set permissions for an external debugger.<br /><br /><b><u>Sample Program</u></b></div><div><b><u><br /></u></b></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/_rkBB8V8TgZY/TMbCTvv1f9I/AAAAAAAAAUs/kPrwRO6vT2M/s1600/led1.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="161" src="http://1.bp.blogspot.com/_rkBB8V8TgZY/TMbCTvv1f9I/AAAAAAAAAUs/kPrwRO6vT2M/s320/led1.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 1. Sample program - led1.c</td></tr></tbody></table><div>This sample program named 'led1.c', is only used to demonstrate remote debugging.</div><div><br /><b><u>The Preparation</u></b></div><div class="separator" style="clear: both; text-align: auto;"><br /></div><div>Connect the LaunchPad to the system. Now the sample program is cross-compiled, and downloaded into the LaunchPad.<br />For further details, refer:<br /><a href="http://harijohnkuriakose.blogspot.com/2010/10/switching-on-launchpad-leds.html">switching-on-launchpad-leds.html</a><br /><br />For necessary reasons, I am calling the current terminal, "<b>Terminal1</b>".<br /><br />The '<b>mspdebug</b>' has a built-in command that enables it to run a GDB remote stub on a specified TCP/IP port. If no port is specified, 2000 is taken as default.<br /><br />Give as:<br />&nbsp;&nbsp; &nbsp;<b>(mspdebug) gdb</b><br /><br />A message will be displayed as:<br />&nbsp;&nbsp; &nbsp;<b>Bound to port 2000. Now waiting for connection...</b><br /><br />At this time, open another terminal. I'm calling it "<b>Terminal2</b>".<br />In Terminal2, give as:<br />&nbsp;&nbsp; &nbsp;<b>msp430-gdb -q a.out</b><br /><br />Here, 'a.out' is the LaunchPad-specific executable binary obtained by cross-compiling the above sample program.<br /><br />Now, connect to the remote machine already waiting in port 2000 as:<br />&nbsp;&nbsp; &nbsp;<b>(gdb) target remote localhost:2000</b><br /><br />An acknowledgement message will be displayed as:<br />&nbsp;&nbsp; &nbsp;<b>Remote debugging using localhost:2000</b><br />&nbsp;&nbsp; &nbsp;<b>0x0000fc00 in _reset_vector__ ()</b><br /><br />If you check back in Terminal1, messages similar to the following will have been displayed:<br />&nbsp;&nbsp; &nbsp;<b>Client connected from 127.0.0.1:47558</b><br />&nbsp;&nbsp; &nbsp;<b>Clearing all breakpoints...</b><br />&nbsp;&nbsp; &nbsp;<b>Reading 2 bytes from 0xfc00</b><br /><br />The current states of the two terminals is as shown:</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_rkBB8V8TgZY/TMbEVjegF_I/AAAAAAAAAUw/b9gcPoUeKVo/s1600/t1nt2-1.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="164" src="http://2.bp.blogspot.com/_rkBB8V8TgZY/TMbEVjegF_I/AAAAAAAAAUw/b9gcPoUeKVo/s320/t1nt2-1.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 2. Terminal1 (left side) &nbsp;and Terminal 2 (right side)</td></tr></tbody></table><div>On listing 'led1.c' in Terminal2, the memory addresses from which the bytes are read will be displayed in Terminal1, simultaneously.</div><div><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/_rkBB8V8TgZY/TMbFfzZmXdI/AAAAAAAAAU0/T6gY7iyHHKw/s1600/t1nt2-2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="165" src="http://1.bp.blogspot.com/_rkBB8V8TgZY/TMbFfzZmXdI/AAAAAAAAAU0/T6gY7iyHHKw/s320/t1nt2-2.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 3. Listing the sample program</td></tr></tbody></table><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_rkBB8V8TgZY/TMbGr9yUWNI/AAAAAAAAAU4/8RgWZTSv8qU/s1600/t1nt2-3.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="166" src="http://2.bp.blogspot.com/_rkBB8V8TgZY/TMbGr9yUWNI/AAAAAAAAAU4/8RgWZTSv8qU/s320/t1nt2-3.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 4. Single stepping through runtime libraries</td></tr></tbody></table><div>On further single steps from this point, the runtime libraries through which the control passes until main( ) is reached, can be observed directly !!!<br />Notice that a considerable number of bytes have been read.<br /><br />Now, single step till the instruction 'P1OUT = 0x01' is reached.&nbsp;</div><div><br /></div><div><b><u>The Action</u></b></div><div><br /></div><div>At this point, the next single step will cause it to execute, which will pass a high voltage (binary 1) to the red led on the LaunchPad, i.e., do it, and see the red LaunchPad led (P1.0) flash bright !!!</div><div><br />On next step, a binary 0 is passed to P1.0, causing it to be off.<br /><br />Single step again, and see the green LaunchPad led (P1.6) flash before your eyes !!!<br /><br />Turn it off too, and keep on single stepping, until you relish the wonderful thing thats happening infront of you ... This is GDB at its best !!!</div><div>At all these points, the memory addresses from which reading takes place are displayed in Terminal1.</div><div><br /><b>N. B.</b>&nbsp;</div><div><ul><li>Properly exit from both mspdebug in Terminal1 and GDB in Terminal2, before disconnecting the LaunchPad from the system.</li><li>Exit from GDB in Terminal2 first, and then mspdebug in Terminal1.</li></ul><b><u></u></b><br /><b><u></u></b><br /><b><u><div><span class="Apple-style-span" style="-webkit-text-decorations-in-effect: none; font-weight: normal;"><b><u><br /></u></b></span></div><div><span class="Apple-style-span" style="-webkit-text-decorations-in-effect: none; font-weight: normal;"><b><u>Addendum</u></b></span></div></u></b><br />It was one of the cutest moments, to actually 'see' GDB in work.&nbsp;</div><div>I am crazy on LaunchPad !!!&nbsp;</div>