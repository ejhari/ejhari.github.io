---
layout: post
title: ! 'C and Python: A Language Faceoff'
date: '2010-09-05T23:25:00.010+05:30'
author: Hari John Kuriakose
tags:
- C
- python
- computing
modified_time: '2010-11-25T22:00:09.419+05:30'
blogger_id: tag:blogger.com,1999:blog-3368921059404601044.post-443227973879145318
blogger_orig_url: http://harijohnkuriakose.blogspot.com/2010/09/c-and-python-language-faceoff.html
---

1. <u>Data Types</u><br />&nbsp;&nbsp; &nbsp;Python is a good example for a <b>dynamically typed </b>programming<br />&nbsp;&nbsp; &nbsp;language. It&nbsp;means that,&nbsp;there are no need for type declarations. Any data<br />&nbsp;&nbsp; &nbsp;can be initialized&nbsp;directly and the&nbsp;corresponding type&nbsp;will be automatically<br />&nbsp;&nbsp; &nbsp;assigned and&nbsp;understood by the Python interpreter.<br />&nbsp;&nbsp; &nbsp;<i>&gt;&gt;&gt;a = 12</i><br /><i>&nbsp;&nbsp; &nbsp;&gt;&gt;&gt;c = 'hello'</i><br /><i>&nbsp;&nbsp; &nbsp;</i><br /><i>&nbsp;&nbsp; &nbsp;</i>C is a <b>statically typed </b>language.<b> </b>We need to first declare the variable.<br />&nbsp;&nbsp; &nbsp;Only&nbsp;then are we&nbsp;allowed<i>&nbsp;</i>to define it<i>. </i>The C compiler will understand<br />&nbsp;&nbsp; &nbsp;the type<i>&nbsp;</i>of&nbsp;the&nbsp;data and assign suitable&nbsp;storage space only when we<br />&nbsp;&nbsp; &nbsp;declare it.<br /><i>&nbsp;&nbsp; &nbsp;$ int a, b=2;</i><br /><i></i><i>&nbsp;&nbsp; &nbsp;$ char c = 'h';</i><br /><i></i><i>&nbsp;&nbsp; &nbsp;$ a=10;</i><br /><br />2. <u>Array Indexing</u><br />&nbsp;&nbsp; &nbsp;The mechanism of array indexing in C is as follows:<br />&nbsp;&nbsp; &nbsp;array index is given by '<b>base address + offset</b>'<br />&nbsp;&nbsp; &nbsp;Therefore, how large be the array length, C compiler only needs to add<br />&nbsp;&nbsp; &nbsp;the&nbsp;offset to the&nbsp;base address to access the required array location.<br /><br />&nbsp;&nbsp; &nbsp;In Python, the situation is different. It is compulsory for its interpreter to<br />&nbsp;&nbsp; &nbsp;follow&nbsp;2 rules:<br />&nbsp;&nbsp; &nbsp;i. <b>check whether current array index is out of bound</b><br />&nbsp;&nbsp; &nbsp;ii. <b>access that index location</b><br /><br />&nbsp;&nbsp; &nbsp;In short, its even possible to go out of bound in C. Garbage values in<br />&nbsp;&nbsp; &nbsp;that&nbsp;locations will&nbsp;be returned. Thats all. But Python is very<br />&nbsp;&nbsp; &nbsp;conservative. You&nbsp;specify an array length, you&nbsp;better stay inside it. No<br />&nbsp;&nbsp; &nbsp;bending rules.<br /><br />&nbsp;&nbsp; &nbsp;Finally, the outcome. As you can guess, array indexing in C is blazing<br />&nbsp;&nbsp; &nbsp;fast. If&nbsp;we work&nbsp;on the same array in Python, we may have to wait.<br />&nbsp;&nbsp; &nbsp;Maybe really long.<br /><br />3. <u>Dynamic Allocations</u><br />&nbsp;&nbsp; &nbsp;On the outset, i take the privilege to assume you know what dynamic<br />&nbsp;&nbsp; &nbsp;allocations are.<br /><br />&nbsp;&nbsp; &nbsp;They are <b>very troublesome in C</b>. Simply speaking, if you do an <i>&nbsp;</i><br /><i>&nbsp;&nbsp; &nbsp;malloc(),&nbsp;</i>then use the&nbsp;same pointer to do&nbsp;another <i>malloc(),</i>&nbsp;you will<br />&nbsp;&nbsp; &nbsp;lose control of the&nbsp;firstly allocated memory&nbsp;block forever. You can't<br />&nbsp;&nbsp; &nbsp;use it anymore.&nbsp;So be wary. Thats all you can do.<br /><br />&nbsp;&nbsp; &nbsp;For this matter, Python is awesome. It will take care of such<br />&nbsp;&nbsp; &nbsp;unhandled&nbsp;allocations of&nbsp;memory automatically. Its called <b>garbage&nbsp;</b><br /><b>&nbsp;&nbsp; &nbsp;collection</b> or <b>automatic&nbsp;</b><b>memory management</b>. We&nbsp;can say that, each<br />&nbsp;&nbsp; &nbsp;allocated block has a <b>reference&nbsp;</b><b>count</b>, which has the value of the<br />&nbsp;&nbsp; &nbsp;number of pointers currently pointing to that&nbsp;particular block. This<br />&nbsp;&nbsp; &nbsp;count, is incremented or decremented automatically and&nbsp;accurately.<br />&nbsp;&nbsp; &nbsp;There is one consequence, though. The&nbsp;<b>compilation time will be&nbsp;</b><br /><b>&nbsp;&nbsp; &nbsp;non-deterministic</b> because we cant predict when and how Python<br />&nbsp;&nbsp; &nbsp;attempts this.<br /><br />4. <u>Indentation</u><br />&nbsp;&nbsp; &nbsp;In short, indentation is <b>compulsory in Python</b>. The intermezzo coding<br />&nbsp;&nbsp; &nbsp;style&nbsp;proposes 4&nbsp;spaces. While the Google coders are seen to be using<br />&nbsp;&nbsp; &nbsp;only 2.<br />&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;In C, it is just the other way. Here, it is only a matter of <b>user&nbsp;</b><br /><b>&nbsp;&nbsp; &nbsp;readability</b>.&nbsp;The C compiler&nbsp;doesn't&nbsp;care.<br /><br />5. <u>Functions</u><br />&nbsp;&nbsp; &nbsp;In Python, all the functions, both built-in and user-defined, are <b>first&nbsp;</b><br /><b>&nbsp;&nbsp; &nbsp;class</b>.&nbsp;A function is said&nbsp;to be first class, if it can be treated just as a<br />&nbsp;&nbsp; &nbsp;variable. It means&nbsp;that, in Python, functions can&nbsp;be passed as<br />&nbsp;&nbsp; &nbsp;parameters, and returned too. Coool,&nbsp;eh? If so, how about knowing<br />&nbsp;&nbsp; &nbsp;that this&nbsp;concept can be extended to creating&nbsp;<b>higher order functions</b>?<br />&nbsp;&nbsp; &nbsp;They are functions which&nbsp;operate on other functions,&nbsp;e.g. integration,<br />&nbsp;&nbsp; &nbsp;differentiation. Three built-in higher order&nbsp;functions in Python&nbsp;are<br /><i>&nbsp;&nbsp; &nbsp;map,&nbsp;</i><i>filter </i>and <i>reduce.</i><br /><br /><i></i>&nbsp;&nbsp; &nbsp;In C, its just the contradictory. Functions are functions, variables are<br />&nbsp;&nbsp; &nbsp;variables.&nbsp;No mixing up.<br /><br />6. <u>Pointers</u><br /><u></u>&nbsp;&nbsp; &nbsp;They are the most awesome weapon in C. You can do powerful things<br />&nbsp;&nbsp; &nbsp;with&nbsp;them, that can be&nbsp;either only dreamed of or very hard to<br />&nbsp;&nbsp; &nbsp;accomplish in other&nbsp;languages. But as powerful they&nbsp;are, be very<br />&nbsp;&nbsp; &nbsp;careful with the memory&nbsp;manipulations&nbsp;you can do with them, or else<br />&nbsp;&nbsp; &nbsp;you are a goner.<br /><br />&nbsp;&nbsp; &nbsp;They are not as such implemented in Python. But some similarity can be<br />&nbsp;&nbsp; &nbsp;felt in&nbsp;some&nbsp;operations that can be performed. For a brief idea, refer to<br />&nbsp;&nbsp; &nbsp;<a href="http://harijohnkuriakose.blogspot.com/2010/08/pointers-in-python.html">"Pointers" in Python</a>.<br /><br />7. <u>Assignments in Expressions</u><br /><u></u>&nbsp;&nbsp; &nbsp;In C its possible to write,<br />&nbsp;&nbsp; &nbsp;$ int a, b=1;<br /><i>&nbsp;&nbsp; &nbsp;$ if ((a=12)&gt;b)</i><br /><i></i>&nbsp;&nbsp; &nbsp;$ &nbsp; &nbsp; &nbsp; &nbsp; <i>print (" %d \n", a+b);</i><br /><br />&nbsp;&nbsp; &nbsp;Well, its not possible in Python. Only logical equality (==) can occur<br />&nbsp;&nbsp; &nbsp;inside an&nbsp;expression.